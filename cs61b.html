<!DOCTYPE html>
<html>
    <head>
        <title>CS 61B | Matthew T. Sit</title>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
        <link rel="stylesheet" href="assets/css/style.css">
        <link href='https://fonts.googleapis.com/css?family=Lato:100,300,400,700' rel='stylesheet' type='text/css'>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js">
        </script>
        <script src = "assets/js/script.js"></script>
        <script src = "assets/js/hiddenscript.js"></script>
        <!-- All code snippet formatting by http://hilite.me/ (friendly styling)-->
    </head>
    <body>
        <div id="navbar-menu-btn">
            <img src="assets/img/menu.png">
        </div>
        <div class="navbar">
            <ul>
                <a href="index.html#content"><li class="navbar-btn">home</li></a>
                <a href="index.html#objective-section"><li class="navbar-btn">objective</li></a>
                <a href="index.html#projects-section"><li class="navbar-btn">projects</li></a>
                <a href="index.html#contact-section"><li class="navbar-btn">contact</li></a>
            </ul>
        </div>
        <div class="proj-banner-container">
            <img src="assets/img/61bl/spring.jpg" class="proj-banner">
            <div class="proj-banner-text-container">
                <a href="http://datastructur.es" target="_blank" class="proj-banner-title">CS 61B, Data Structures</a>
                <div class="proj-banner-position">Matt's Notes</div>
            </div>
        </div>
        <div class="proj-summary">
            <div>
                <img src="assets/img/down.png" class="proj-down">
            </div>
            <div>
            	<em>Welcome!</em> Here are some notes from our sections together!<br>
	    	Click on any link below to view.
            </div>
            <div>
                <div class="proj-summary-right-col">
                    <div class="proj-summary-cluster-right">
                        <div class="proj-summary-header">Spring 2018</div>
                        <div class="proj-summary-detail">
                            <a href="#content">
                                dis 01. intro to java!
                                <img src="assets/img/right.png">
                            </a>
                  	     </div>
                         <div class="proj-summary-detail">
                             <a href="#content">
                                 dis 02. static and intlists.
                                 <img src="assets/img/right.png">
                             </a>
                   	     </div>
                         <div class="proj-summary-detail">
                             <a href="#content">
                                 dis 03. linkedlists and arrays.
                                 <img src="assets/img/right.png">
                             </a>
                   	     </div>
                         <div class="proj-summary-detail">
                             <a href="#content">
                                 dis 04. inheritance.
                                 <img src="assets/img/right.png">
                             </a>
                   	     </div>
                         <div class="proj-summary-detail">
                             <a href="#content">
                                 dis 07. asymptotics I.
                                 <img src="assets/img/right.png">
                             </a>
                   	     </div>
                    </div>
                </div>
            </div>
        </div>
        <section id="content"></section>

        <div class="proj-content-container" id="template">
            <div class="proj-content-header">Dis 00. Template.</div>
            January 00, 2018.
            <br>
            <div class="proj-content-text">

            </div>
        </div>

        <div class="proj-content-container" id="07">
            <div class="proj-content-header">Dis 07. Asymptotics I.</div>
            February 27, 2018.
            <br>
            <div class="proj-content-text">
                We talked about the formal definition of the asymptotic bounds and
                we made it our goal to gain intuition for how they work so that we don't have to setup a limit explictily every single time.
                The summer CS61BL website has a great and thorough explanation of this again for you: <a href='http://www.cs61bl.org/su17/materials/lab/lab07/lab07.html#d-abbreviated-estimates' target="_blank">CS 61BL Lab 07</a>
                <br><br>
                Further, we plotted some lines using an iPython notebook just so that we can see what some
                functions look like and why it would make sense to want the asymptotic definitions we have.
                You can see the notebook we were looking at here: <a href='Asymptotic+Analysis.html' target="_blank">iPython notebook</a>
                <br><br>
                Some strategies for asymptotic analysis:
                <ul>
                    <li>Try some test inputs to see what the function does and to get a feel for its flow.</li>
                    <li>Label lines of code with their runtime to determine if some are insignficant compared to more expensive lines.</li>
                    <li>If there are nested loops, draw bars.</li>
                    <li>If there is a recursion, draw a tree representing the function calls.</li>
                    <li>Perhaps represent and simplify a mathematical expression.</li>
                </ul>
                Remember that your usage of Big-O, Big-Omega, or Big-Theta depends on the exact question being asked.<br><br>
                If you are simply asked for the runtime of the function and you find that you cannot give a tight bound, you should give an upper bound and possibly a lower bound as well if it is meaningful.
                These bounds would describe the range of runtimes for all possible cases of inputs.<br><br>
                If for the same code you are asked specifically for the best case or worst case runtime, then you would give the same magnitude answer as your lower or upper bound, respectively, but you would present it as a tight bound.
                This is because the best (or worst) case is one particular case (one particular input) and thus you would state that that one case is tightly bound by a particular function; it doesn't really make sense to say that one case is lower or upper bounded (it's vague to state that when you can provide a tight bound instead).
            </div>
        </div>

        <div class="proj-content-container" id="04">
            <div class="proj-content-header">Dis 04. Inheritance.</div>
            February 6, 2018.
            <br>
            <div class="proj-content-text">
            <a href="https://docs.google.com/presentation/d/1uN5LwebE8ntlJHJTsCixhP4squ-r_xVUC2vcq8FfUXM/edit?usp=sharing">
              Click here to view slides from this discussion.
            </a>
            </div>
        </div>

        <div class="proj-content-container" id="03">
            <div class="proj-content-header">Dis 03. LinkedLists and Arrays.</div>
            January 30, 2018.
            <br>
            <div class="proj-content-text">
              <em>Our Story of LinkedLists</em><br>
              We started out with the raw <i>IntList</i>.
              This was a nice a simple data structure that we could use
              to store individual integers in a series of connected links.
              <br><br>
              Next came the <i>Singly Linked List</i>, which allowed us to
              encapsulate our raw IntList. The advantage of encapsulation is that
              it allows us to provide for our users methods for performing operations
              on our data structure so that they do not need to be knowledgeable
              about the underlying intricacies of our implementation in our to use it;
              they can simply refer to an API or list of our methods and their descriptions
              and they can use our data structure like a black box.
              <br><br>
              Following that, we introduced <i>Sentinels</i> into our Singly Linked List.
              This was a "dummy" node that had an unimportant item that was always included.
              The purpose of a sentinel is to remove the need for null checks, since those can be
              messy in our code or it may be easy to miss a couple situations. Thus, instead of
              checking if an instance is null, we can check if it has returned back to the sentinel.
              <br><br>
              Finally, we allowed ourselves to have referenes in both directions, so
              that we could access both the previous and the next. This was the <i>Doubly Linked List</i>.
              <br><br>
              <em>Problem Solving Strategies</em><br>
              Whenever you are asked to write a signficant amount of code by hand,
              first make a concrete example for yourself so that you understand what
              the problem is asking you to do, so that you get a feel for the operations
              that may be involved, and so that you have something to check against once you
              actually start writing code in a bit.
              <br><br>
              Next, break down the problem into functional parts or steps that you know how to do.
              If you are stuck, write out the parts of the code that are most obvious to you, even
              if you have to leave conditions or other things blank. For example, if we have to do
              an operation repeatedly, you know that there would have to be a loop or a recursive call,
              so you can set up the components for that first while you're still thinking (loop conditions,
              incrementations, base cases, etc.). Try to get the general situation working first, and then
              worry about the edge cases once you're done. Often times, those can be addressed by adding a simple
              if case at the top of your code later.
              <br><br>
              <em>Arrays vs LinkedLists</em><br>
              Finally, we informally made observations about the arrays and linkedlists
              that we worked with today. We'll cover these in more detail later when
              we study runtime analysis. But for now, we saw that it was easier to get items
              out of an array, but that it was harder to "resize" them since they are of fixed length and so
              that would actually require us to make a new array and to copy everything over.
              LinkedLists on the other hand, require that we traverse the list in order to access
              a particular item, but it only requires us to switch around a few pointers to insert or delete items.
            </div>
        </div>

        <div class="proj-content-container" id="02">
            <div class="proj-content-header">Dis 02. Static and IntLists.</div>
            January 23, 2018.
            <br>
            <div class="proj-content-text">
              <em>Architecture of a Class</em><br>
              Typical class definitions contain three sections of code.
              <br><br>
              First we have <b>fields</b>, which consist of class variables and instance variables that
              are useful for storing attributes, state, characteristics, data, etc.
              Class variables have the keyword <em>static</em> and thus each only hold one value that
              is shared among all object instances of the class. Instance variables are non-static declarations
              that contain unique values for every object instance made.
              <br><br>
              Next are the <b>constructors</b>, which are necessarily invoked when the user of
              your class wants to make a new object instance. The code inside constructors should be responsible
              for accepting some arguments, and storing those inputs into the fields.
              <br><br>
              Finally we have <b>methods</b> or functions. These may accept input, and may
              interact with and modify the fields before potentially returning some result.
              <br><br>
              Here is an example of these three components in action.
              <div class="proj-content-text">
                <div style="background: #f0f0f0; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21  </pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #007020; font-weight: bold">public</span> <span style="color: #007020; font-weight: bold">class</span> <span style="color: #0e84b5; font-weight: bold">Waffle</span> <span style="color: #666666">{</span>

    <span style="color: #60a0b0; font-style: italic">// Fields</span>
    <span style="color: #007020; font-weight: bold">private</span> <span style="color: #902000">boolean</span> isDelicious<span style="color: #666666">;</span>
    <span style="color: #007020; font-weight: bold">private</span> <span style="color: #902000">int</span> numStrawberries<span style="color: #666666">;</span>

    <span style="color: #60a0b0; font-style: italic">// Constructors</span>
    <span style="color: #007020; font-weight: bold">public</span> <span style="color: #06287e">Waffle</span><span style="color: #666666">(</span><span style="color: #902000">boolean</span> isDelicious<span style="color: #666666">,</span> <span style="color: #902000">int</span> numStrawberries<span style="color: #666666">)</span> <span style="color: #666666">{</span>
        <span style="color: #007020; font-weight: bold">this</span><span style="color: #666666">.</span><span style="color: #4070a0">isDelicious</span> <span style="color: #666666">=</span> isDelicious<span style="color: #666666">;</span>
        <span style="color: #007020; font-weight: bold">this</span><span style="color: #666666">.</span><span style="color: #4070a0">numStrawberries</span> <span style="color: #666666">=</span> numStrawberries<span style="color: #666666">;</span>
    <span style="color: #666666">}</span>

    <span style="color: #60a0b0; font-style: italic">// Methods</span>
    <span style="color: #007020; font-weight: bold">public</span> <span style="color: #902000">boolean</span> <span style="color: #06287e">isDelicious</span><span style="color: #666666">()</span> <span style="color: #666666">{</span>
        <span style="color: #007020; font-weight: bold">return</span> isDelicious<span style="color: #666666">;</span>
    <span style="color: #666666">}</span>

    <span style="color: #007020; font-weight: bold">public</span> <span style="color: #902000">void</span> <span style="color: #06287e">addStrawberries</span><span style="color: #666666">(</span><span style="color: #902000">int</span> num<span style="color: #666666">)</span> <span style="color: #666666">{</span>
        <span style="color: #007020; font-weight: bold">this</span><span style="color: #666666">.</span><span style="color: #4070a0">numStrawberries</span> <span style="color: #666666">+=</span> num<span style="color: #666666">;</span>
    <span style="color: #666666">}</span>
<span style="color: #666666">}</span>
</pre></td></tr></table></div></div>
          <em>Static Methods and Variables</em><br>
          Fields can be labeled as <em>static</em> (class variables),
          and methods can also be labeled as <em>static</em>.
          <br><br>
          For static fields, there is only one variable that is shared among all
          instances of the class, and thus consequently, all object instances see the same value for that field
          (again, because there is a single variable shared among all; there is not one variable per instance).
          To call upon a static field, we use dot notation on the class name rather than on a particular instance.
          <br><br>
          For static methods, an object instance is not required for the function to be called.
          As a consequence, it cannot access non-static fields.
          If you'd like, you can call static methods on an object instance, but in that case
          Java will lookup the class of the instance and call it as we've just described.
          <br><br>
          <em>IntLists</em><br>
          You'll often see statements such as <i>L.rest.rest = L.rest.rest.rest;</i>,
          but sometimes it seems like the way you follow the "rests" seem different
          for the left and right sides of the equals sign. Why is that?
          <br><br>
          Think about what the equals sign means. For example, let's look at an assignment
          statement such as this: <i>String var = "object";</i>. What this the box and
          pointer diagram look like?
          <br><br>
          <iframe width="100%" height="300" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=public%20class%20YourClassNameHere%20%7B%0A%20%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%20%7B%0A%20%20%20%20%20%20String%20var%20%3D%20%22object%22%3B%0A%20%20%20%20%7D%0A%7D&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=3&heapPrimitives=true&origin=opt-frontend.js&py=java&rawInputLstJSON=%5B%5D&textReferences=false"> </iframe>
          <br><br>
          We can see that <i>var</i> corresponds to a variable box in the diagram,
          and that the right hand side of the assignment statement was a String object.
          <br><br>
          In the same way, the left side of the statement <i>L.rest.rest = L.rest.rest.rest;</i>
          is a variable box in the diagram, and the right hand side is an IntList object.
          Therefore, when we count the number of "rests" for the left hand side, we stop
          counting in time so that we are left with the last "rest" variable box so that we can reassign it.
          When we count for the right hand side, we follow the final "rest" to an Object, and assign the
          left hand side to reference it.
          <br><br>
          Walk through this simple example and make sure you understand how this statement works and why.
          <br><br>
          <iframe width="100%" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=public%20class%20IntList%20%7B%0A%20%20%20%20int%20first%3B%0A%20%20%20%20IntList%20rest%3B%0A%20%20%20%20%0A%20%20%20%20IntList%28int%20first,%20IntList%20rest%29%20%7B%0A%20%20%20%20%20%20this.first%20%3D%20first%3B%0A%20%20%20%20%20%20this.rest%20%3D%20rest%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%20%7B%0A%20%20%20%20%20%20IntList%20L%20%3D%20new%20IntList%281,%20new%20IntList%282,%20new%20IntList%283,%20new%20IntList%284,%20null%29%29%29%29%3B%0A%20%20%20%20%20%20L.rest.rest%20%3D%20L.rest.rest.rest%3B%0A%20%20%20%20%7D%0A%7D&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=30&heapPrimitives=true&origin=opt-frontend.js&py=java&rawInputLstJSON=%5B%5D&textReferences=false"> </iframe>
          <br><br>
          <em>Destructive vs. Non-Destructive</em><br>
          When writing a destructive function, you want to destroy the original and so you should not be
          creating new objects. Thus, destructive functions do not use the <i>new</i> keyword.
          <br><br>
          On the other hand, non-destructive functions want to preserve the original and return a new version.
          Thus, non-destructive functions should use the <i>new</i> keyword to create fresh objects as the
          necessary modifications are applied.
          </div>
        </div>


        <div class="proj-content-container" id="01">
            <div class="proj-content-header">Dis 01. Introduction to Reading and Writing Java!</div>
            January 16, 2018.
            <br>
            <div class="proj-content-text">
              Java programs begin execution starting from a main method <i>public static void main (String[] args) {...}</i>.
              <br><br>
              <em>Primitives vs. Non-Primitives</em><br>
              We keep track of data using variables. Variables come in two flavors: primitives and non-primitives.
              <b>Primitives</b> in Java include only the following: byte, short, int, long, float, double, boolean, char.
              All other kinds of variables are <b>non-primitives</b>.
              Variables representing primitives store the appropriate raw value, while
              variables representing non-primitives store <b>references</b> to the actual data.
              <br><br>
              The creators of Java made this design decision for the language due to efficiency justifications.
              Imagine that you're in at an interview for your dream job. The manager really loves you and is almost ready
              to hire you, but first, they'd like to ensure that everything you've said about yourself is true.
              And so, the manager would like to verify with your best friend that you have indeed been truthful.
              But now the question is, would it be appropriate for you to clone your best friend so that the manager
              can chat with them?
              Probably not...your friend might not appreciate that very much.
              It makes much more sense to provide the manager with a <i>reference</i> to your friend, a phone number perhaps.
              This is why Java handles "complicated" (non-primitive) variables using references.
              <br><br>
              This goes hand-in-hand with what Professor Hug calls the <b>Golden Rule of Equals</b>.
              When we are drawing <b>box and pointer diagrams</b>, when a variable's contents are asked of,
              we provide whatever is inside that variable's corresponding box.
              This means that for primitives we copy the raw value,
              while for non-primitives we copy the arrow that we have drawn, such that
              our copied arrow points to the same destination.
              Given this distinction, if a function takes in both a primitive and a non-primitive
              as arguments, and it mangles both during the function call, when the function is over,
              which of the two (or both?) were actually changed?
              See the example below to find out:
              <br><br>
<iframe width="100%" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=public%20class%20Mangler%20%7B%0A%20%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%20%7B%0A%20%20%20%20%20%20int%5B%5D%20myArr%20%3D%20%7B3,%200,%204,%206,%203%7D%3B%0A%20%20%20%20%20%20int%20myK%20%3D%202%3B%0A%20%20%20%20%20%20mangle%28myArr,%20myK%29%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20public%20static%20void%20mangle%28int%5B%5D%20arr,%20int%20k%29%20%7B%0A%20%20%20%20%20%20arr%5B0%5D%20%3D%205%3B%0A%20%20%20%20%20%20k%20%3D%201%3B%0A%20%20%20%20%7D%0A%7D&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=false&origin=opt-frontend.js&py=java&rawInputLstJSON=%5B%5D&textReferences=false"> </iframe>
              <br><br>
              <em>Iteration and Recursion</em><br>
              Often times, we want to write code that does something over and over again.
              We have two techniques for doing this: iteration and recursion.
              <br><br>
              <b>Iteration</b> involves using a loop.
              In Java, one kind of loop is the <i>while</i> loop.
              To evaluate it, we follow these steps in order:
              <ol>
                <li>Evaluate the loop condition.
                  If it is <i>false</i> the loop is over and execution continues starting after
                  the closing curly bracket of the loop.</li>
                <li>If it is <i>true</i>, then we start at the top of the loop's body of code and execute those lines in order until we reach its end.</li>
                <li>At this point, we go back to step 1 and check the condition again.</li>
              </ol>
              It is important to note that even if the condition becomes false in the middle of executing the loop body,
              the loop does not magically quite immediately. The loop can only quit in between executions of its body
              (unless there is a <i>break</i> statement, an <i>Exception</i> is thrown, etc.).
              Another kind of loop is the <i>for</i> loop.
              This kind of loop was introduced because programmers noticed that loops in general typically
              contained the initialization of some counter variable, the check of some condition against that counter variable,
              and the modification of this counter variable as iterations occur.
              For loops simply bundle these three elements together into a visually convenient place.
              We evaluate for loops following these steps in order:
              <ol>
                <li>Initialize the counter variable.</li>
                <li>Evaluate the loop condition.
                  If it is <i>false</i> the loop is over and execution continues starting after
                  the closing curly bracket of the loop.</li>
                <li>If it is <i>true</i>, then we start at the top of the loop's body of code and execute those lines in order until we reach its end.</li>
                <li>Adjust the counter value according to the specified fashion. Usually an incrementation or decrementation.</li>
                <li>At this point, we go back to step 2 and check the condition again.</li>
              </ol>
              The other option we have is <b>recursion</b>.
              This occurs anytime we have a function and that function's body of code contains a statement in which it calls upon itself again.
              To prevent infinite recursion, we want our recursive functions to contain <i>base cases</i>,
              which are if statements that provide direct results of the simplest situations,
              and in all other cases our recursive calls should aim to move our complicated situation
              closer and closer to one of our base cases.
              <br><br>
              With the classic Fibonacci exercise (#3 on the worksheet), we
              saw how there may be many ways to solve the same problem and to
              arrive at the correct answer.
              Therefore, simply solving a problem one way is cute and all,
              but in the real world, that doesn't mean you're done--we want to find the "best" solution.
              What does "best" mean?
              It means code that is not only correct, but also fast, memory efficient, and clear to other human readers.
              In other words, in this class we will learn to consider
              time efficiency, space efficiency, and style/documentation.
            </div>
        </div>
    </body>
</html>
